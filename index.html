<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Previsão 15 dias — Preto & Branco</title>
    <style>
        :root {
            --bg: #ffffff;
            --fg: #000000;
            --muted: #333333;
            --card: #f6f6f6
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            background: var(--bg);
            color: var(--fg);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        header {
            display: flex;
            gap: 16px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .brand {
            display: flex;
            gap: 14px;
            align-items: baseline;
            flex-wrap: wrap;
        }

        .brand h1 {
            font-size: 18px;
            margin: 0;
            font-weight: 700;
            letter-spacing: 0.2px
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        input[type=text] {
            padding: 12px 14px;
            border: 1px solid var(--muted);
            background: #fefefe;
            color: var(--fg);
            font-size: 14px;
            min-width: 220px;
            flex: 1;
            border-radius: 8px;
            transition: all 0.25s ease;
        }

        input[type=text]:focus {
            outline: none;
            border-color: var(--fg);
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
        }

        button {
            padding: 12px 18px;
            border: 1px solid var(--fg);
            background: var(--fg);
            color: var(--bg);
            cursor: pointer;
            font-weight: 600;
            border-radius: 8px;
            transition: all 0.25s ease;
        }

        button:hover,
        button:focus {
            background: var(--bg);
            color: var(--fg);
        }

        .meta {
            font-size: 13px;
            color: var(--muted);
        }

        main {
            display: block
        }

        .location-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-top: 6px;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }

        .cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 14px;
        }

        .card {
            background: var(--card);
            border: 1px solid #e8e8e8;
            padding: 14px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .card .date {
            font-weight: 700
        }

        .row {
            display: flex;
            justify-content: space-between;
            font-size: 13px
        }

        .small {
            font-size: 12px;
            color: var(--muted)
        }

        footer {
            margin-top: 18px;
            font-size: 13px;
            color: var(--muted)
        }

        @media (max-width:520px) {

            header {
                display: grid;
                justify-content: center;
                justify-items: center;
                text-align: center;
            }

            input[type=text] {
                min-width: 100%;
            }

            button {
                width: 100%;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            #locationName {
                align-self: center;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="brand">
            <h1>Previsão - 15 dias</h1>
        </div>
        <div class="controls">
            <form id="searchForm">
                <input type="text" id="cityInput" placeholder="Buscar cidade (ex: Recife, BR)" value="Recife"
                    aria-label="Buscar cidade" />
                <button type="submit">Buscar</button>
            </form>
        </div>
    </header>

    <main>
        <div class="location-row">
            <div id="locationName" style="font-weight:700">Carregando...</div>
            <div style="margin-left:auto;text-align:right">
                <div class="meta">Hoje: <span id="todayDate"></span></div>
                <div class="small">Dados: Open-Meteo (modelo ecmwf_ifs)</div>
            </div>
        </div>
        <section id="forecastSection">
            <div class="cards" id="cards"></div>
        </section>
    </main>

    <footer>
        Mostrando até 15 dias de previsão. A Busca utiliza a API de geocoding do Open-Meteo.
    </footer>

    <script>
        const geocodeBase = 'https://geocoding-api.open-meteo.com/v1/search';
        const forecastBase = 'https://api.open-meteo.com/v1/forecast';
        const model = 'ecmwf_ifs';

        const cityInput = document.getElementById('cityInput');
        const searchForm = document.getElementById('searchForm');
        const locationName = document.getElementById('locationName');
        const cardsEl = document.getElementById('cards');
        const todayDate = document.getElementById('todayDate');

        const today = new Date();
        const weekday = new Intl.DateTimeFormat('pt-BR', { weekday: 'long' }).format(today);
        const date = new Intl.DateTimeFormat('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' }).format(today);
        todayDate.textContent = `${date} - ${weekday}`;

        function formatDateLabel(iso) {
            const d = new Date(iso);
            const weekday = new Intl.DateTimeFormat('pt-BR', { weekday: 'short' }).format(d);
            const date = new Intl.DateTimeFormat('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' }).format(d);
            return { weekday, date };
        }

        function groupHourlyByDate(times, arrays) {
            const map = new Map();
            for (let i = 0; i < times.length; i++) {
                const day = times[i].slice(0, 10);
                if (!map.has(day)) map.set(day, []);
                const point = {};
                for (const key in arrays) { point[key] = arrays[key][i]; }
                map.get(day).push(point);
            }
            return map;
        }

        function summarizeDay(points) {
            const n = points.length || 1;
            let tMin = Infinity, tMax = -Infinity, rhMin = Infinity, rhMax = -Infinity;
            let precipSum = 0, cloudSum = 0, gustMax = 0;
            for (const p of points) {
                if (p.temperature_2m != null) {
                    if (p.temperature_2m < tMin) tMin = p.temperature_2m;
                    if (p.temperature_2m > tMax) tMax = p.temperature_2m;
                }
                if (p.relative_humidity_2m != null) {
                    if (p.relative_humidity_2m < rhMin) rhMin = p.relative_humidity_2m;
                    if (p.relative_humidity_2m > rhMax) rhMax = p.relative_humidity_2m;
                }
                if (p.precipitation != null) precipSum += p.precipitation;
                if (p.cloud_cover != null) cloudSum += p.cloud_cover;
                if (p.wind_gusts_10m != null && p.wind_gusts_10m > gustMax) gustMax = p.wind_gusts_10m;
            }
            const cloudMean = cloudSum / n;
            return { tMin, tMax, rhMin, rhMax, precipSum, cloudMean, gustMax };
        }

        function renderDays(dayMap) {
            cardsEl.innerHTML = '';
            const entries = Array.from(dayMap.entries()).slice(0, 15);
            for (const [day, points] of entries) {
                const iso = day + 'T00:00:00';
                const labels = formatDateLabel(iso);
                const s = summarizeDay(points);
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
          <div class="date">${labels.date} (${labels.weekday})</div>
          <div class="row"><div class="small">Temp. (°C)</div><div>${isFinite(s.tMin) ? s.tMin.toFixed(0) : '-'} a ${isFinite(s.tMax) ? s.tMax.toFixed(0) : '-'}</div></div>
          <div class="row"><div class="small">Precipitação (mm)</div><div>${s.precipSum.toFixed(1)}</div></div>
          <div class="row"><div class="small">Umidade (%)</div><div>${isFinite(s.rhMin) ? s.rhMin.toFixed(0) : '-'} a ${isFinite(s.rhMax) ? s.rhMax.toFixed(0) : '-'}</div></div>
          <div class="row"><div class="small">Cobertura de nuvens (%)</div><div>${s.cloudMean.toFixed(0)}</div></div>
          <div class="row"><div class="small">Rajadas de vento</div><div>${s.gustMax.toFixed(0)} km/h</div></div>`;
                cardsEl.appendChild(card);
            }
        }

        async function geocode(query) {
            const url = new URL(geocodeBase);
            url.searchParams.set('name', query);
            url.searchParams.set('count', '5');
            url.searchParams.set('language', 'pt');
            const res = await fetch(url.toString());
            if (!res.ok) throw new Error('Erro na geocodificação');
            return await res.json();
        }

        async function fetchForecast(lat, lon, timezone = 'auto') {
            const url = new URL(forecastBase);
            url.searchParams.set('latitude', lat);
            url.searchParams.set('longitude', lon);
            url.searchParams.set('hourly', 'temperature_2m,relative_humidity_2m,precipitation,cloud_cover,wind_gusts_10m');
            url.searchParams.set('models', model);
            url.searchParams.set('timezone', timezone);
            url.searchParams.set('forecast_days', '15');
            const res = await fetch(url.toString());
            if (!res.ok) throw new Error('Erro ao buscar previsão');
            return await res.json();
        }

        async function loadForCity(query) {
            try {
                locationName.textContent = 'Buscando...';
                cardsEl.innerHTML = '';
                const g = await geocode(query);
                if (!g || !g.results || g.results.length === 0) {
                    locationName.textContent = 'Local não encontrado';
                    return;
                }
                const place = g.results[0];
                locationName.textContent = `${place.name}${place.admin1 ? ', ' + place.admin1 : ''}${place.country ? ' - ' + place.country : ''}`;
                const forecast = await fetchForecast(place.latitude, place.longitude, place.timezone ?? 'auto');
                if (!forecast || !forecast.hourly) {
                    locationName.textContent += ' - sem dados disponíveis';
                    return;
                }
                const times = forecast.hourly.time;
                const arrays = {
                    temperature_2m: forecast.hourly.temperature_2m || [],
                    relative_humidity_2m: forecast.hourly.relative_humidity_2m || [],
                    precipitation: forecast.hourly.precipitation || [],
                    cloud_cover: forecast.hourly.cloud_cover || [],
                    wind_gusts_10m: forecast.hourly.wind_gusts_10m || []
                };
                const dayMap = groupHourlyByDate(times, arrays);
                renderDays(dayMap);
            } catch (err) {
                console.error(err);
                locationName.textContent = 'Erro ao carregar';
            }
        }

        searchForm.addEventListener('submit', e => {
            e.preventDefault();
            const q = cityInput.value.trim();
            if (!q) return;
            loadForCity(q);
        });

        window.addEventListener('load', () => { loadForCity(cityInput.value || 'Recife'); });
    </script>
</body>

</html>