<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Previsão 15 dias - ECMWF</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Ubuntu', sans-serif;
            padding: 28px 12px;
            color: #000;
            background: #fff;
        }

        header {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            align-items: center;
            gap: 16px;
            padding: 0px 40px;
        }

        input[type=text],
        button {
            font-family: inherit;
            border-radius: 8px;
            padding: 10px 14px;
            border: 1px solid #333;
        }

        button {
            cursor: pointer;
            background: #000;
            color: #fff;
            font-weight: 600;
        }

        #locationName {
            margin-bottom: 20px;
            text-align: center;
        }

        #summaryCard {
            width: 500px;
            padding: 8px 15px;
            justify-self: center;
        }

        main {
            margin-top: 40px;
        }

        #cards {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }

        .day {
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 32px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .day .date {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .row {
            display: flex;
            justify-content: space-between;
            padding: 16px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .row:last-child {
            border-bottom: none;
        }

        .row p {
            margin: 0;
            font-size: 20px;
        }

        /* cores de texto por categoria */
        .temp {
            color: #d35400;
        }

        .precip {
            color: #003ce1;
        }

        .humidity {
            color: #003ce1;
        }

        .wind {
            color: #00a827;
        }

        .cloud {
            color: #797979;
        }

        footer {
            margin-top: 20px;
            font-size: 13px;
            color: #555;
        }

        @media(max-width:800px) {

            header {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }

            #searchForm {
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
                max-width: 300px;
                gap: 8px;
            }

            #searchForm>button {
                width: 200px;
            }

            #cityInput {
                width: 100%;
                text-align: center;
            }

            #summaryCard {
                width: 327px;
            }

            #cards {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .day {
                padding: 14px;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>Previsão - 15 dias</h1>
        <form id="searchForm">
            <input type="text" id="cityInput" placeholder="Buscar cidade (ex: Recife, BR)" />
            <button type="submit">Buscar</button>
            <button type="button" id="geoButton">Localizar</button>
        </form>
    </header>

    <main>
        <div class="location-row">
            <div id="locationName" style="font-weight:700"></div>
            <div style="display: grid; gap: 20px;margin-bottom: 40px; justify-items: center;">
                <div>Hoje: <span id="todayDate"></span></div>
                <div>Modelo ECMWF (HRES 9 km) (via Open-Meteo)</div>
            </div>
        </div>

        <section id="forecastSection">
            <div id="cards"></div>
        </section>
    </main>

    <script>
        const forecastBase = 'https://api.open-meteo.com/v1/forecast';
        const model = 'ecmwf_ifs';
        const cityInput = document.getElementById('cityInput');
        const searchForm = document.getElementById('searchForm');
        const locationName = document.getElementById('locationName');
        const cardsEl = document.getElementById('cards');
        const todayDate = document.getElementById('todayDate');
        const forecastSection = document.getElementById('forecastSection');

        const today = new Date();
        const weekday = new Intl.DateTimeFormat('pt-BR', { weekday: 'long' }).format(today);
        const date = new Intl.DateTimeFormat('pt-BR', { day: '2-digit', month: '2-digit' }).format(today);
        todayDate.textContent = `${date} - ${weekday}`;

        function formatDateLabel(iso) {
            const d = new Date(iso);
            const weekday = new Intl.DateTimeFormat('pt-BR', { weekday: 'long' }).format(d);
            const date = new Intl.DateTimeFormat('pt-BR', { day: '2-digit', month: '2-digit' }).format(d);
            return { weekday, date };
        }

        function groupHourlyByDate(times, arrays) {
            const map = new Map();
            for (let i = 0; i < times.length; i++) {
                const day = times[i].slice(0, 10);
                if (!map.has(day)) map.set(day, []);
                const point = {};
                for (const key in arrays) point[key] = arrays[key][i];
                point.time = times[i];
                map.get(day).push(point);
            }
            return map;
        }

        function summarizeDay(points) {
            let tMin = Infinity, tMax = -Infinity, rhMin = Infinity, rhMax = -Infinity;
            let precipSum = 0, gustMax = 0;
            let clouds = { madrugada: [], manha: [], tarde: [], noite: [] };

            for (const p of points) {
                const hour = new Date(p.time).getHours();
                if (p.temperature_2m != null) {
                    if (p.temperature_2m < tMin) tMin = p.temperature_2m;
                    if (p.temperature_2m > tMax) tMax = p.temperature_2m;
                }
                if (p.relative_humidity_2m != null) {
                    if (p.relative_humidity_2m < rhMin) rhMin = p.relative_humidity_2m;
                    if (p.relative_humidity_2m > rhMax) rhMax = p.relative_humidity_2m;
                }
                if (p.precipitation != null) precipSum += p.precipitation;
                if (p.wind_gusts_10m != null && p.wind_gusts_10m > gustMax) gustMax = p.wind_gusts_10m;
                if (p.cloud_cover != null) {
                    if (hour >= 0 && hour < 6) clouds.madrugada.push(p.cloud_cover);
                    else if (hour >= 6 && hour < 12) clouds.manha.push(p.cloud_cover);
                    else if (hour >= 12 && hour < 18) clouds.tarde.push(p.cloud_cover);
                    else clouds.noite.push(p.cloud_cover);
                }
            }

            const avg = arr => arr.length ? arr.reduce((a, b) => a + b) / arr.length : 0;
            const round10 = v => Math.round(v / 10) * 10;

            return {
                tMin, tMax, rhMin, rhMax, precipSum, gustMax,
                clouds: {
                    madrugada: round10(avg(clouds.madrugada)),
                    manha: round10(avg(clouds.manha)),
                    tarde: round10(avg(clouds.tarde)),
                    noite: round10(avg(clouds.noite))
                }
            };
        }

        function calculateTotalPrecipitation(dayMap) {
            let total = 0;
            for (const [, points] of dayMap) {
                const s = summarizeDay(points);
                total += s.precipSum;
            }
            return total;
        }

        function renderSummaryCard(dayMap) {
            const existing = document.getElementById('summaryCard');
            if (existing) existing.remove();

            const totalPrecip = calculateTotalPrecipitation(dayMap);

            let rainyDays = 0;
            for (const [, points] of dayMap) {
                const s = summarizeDay(points);
                if (s.precipSum > 0) rainyDays++;
            }

            const card = document.createElement('div');
            card.id = 'summaryCard';
            card.className = 'day';
            card.innerHTML = `
        <h2 style="margin:8px 0px; text-align:center">Resumo para 15 dias</h2>
        <div class="row precip">
            <p style="color:black">Chuva (mm)</p>
            <p>${totalPrecip.toFixed(1)}</p>
        </div>
        <div class="row precip">
            <p style="color:black">Dias de chuva</p>
            <p>${rainyDays} de 15</p>
        </div>
    `;

            forecastSection.parentNode.insertBefore(card, forecastSection);
        }

        function renderDays(dayMap) {
            cardsEl.innerHTML = '';
            const entries = Array.from(dayMap.entries()).slice(0, 15);
            renderSummaryCard(dayMap);

            for (const [day, points] of entries) {
                const iso = day + 'T00:00:00';
                const labels = formatDateLabel(iso);
                const s = summarizeDay(points);

                const avgCloud = Math.round((s.clouds.madrugada + s.clouds.manha + s.clouds.tarde + s.clouds.noite) / 4);
                const storm = points.some(p => [95, 96, 99].includes(p.weathercode)); // ⚡ DETECTA TEMPESTADE

                const card = document.createElement('div');
                card.className = 'day';
                card.innerHTML = `
            <div class="date">${labels.date} - ${labels.weekday}</div>
            <div class="row temp"><p>Temperatura (°C)</p><p>${isFinite(s.tMin) ? s.tMin.toFixed(0) : '-'} a ${isFinite(s.tMax) ? s.tMax.toFixed(0) : '-'}</p></div>
            <div class="row precip"><p>Chuva (mm)</p><p>${s.precipSum.toFixed(1)}</p></div>
            <div class="row humidity"><p>Umidade (%)</p><p>${isFinite(s.rhMin) ? s.rhMin.toFixed(0) : '-'} a ${isFinite(s.rhMax) ? s.rhMax.toFixed(0) : '-'}</p></div>
            <div class="row wind"><p>Rajadas de vento (km/h)</p><p>${s.gustMax.toFixed(0)}</p></div>
            <div class="row cloud"><p>${cloudDescription(avgCloud)} (${avgCloud}%)</p></div>
            ${storm ? `<div class="row" style="color:red;"><p>Risco de tempestades</p></div>` : ''}
            <div style="text-align:center; margin-top:10px;">
                <button class="detail-btn" style="background:#000;color:#fff;border:1px solid #333;padding:10px 14px;border-radius:8px;cursor:pointer;">Detalhes por período</button>
            </div>
        `;

                const detailBtn = card.querySelector('.detail-btn');
                detailBtn.addEventListener('click', () => {
                    card.innerHTML = `
                <div class="date">${labels.date} - ${labels.weekday}</div>
            `;

                    const periods = {
                        madrugada: points.filter(p => {
                            const h = new Date(p.time).getHours();
                            return h >= 0 && h < 6;
                        }),
                        manha: points.filter(p => {
                            const h = new Date(p.time).getHours();
                            return h >= 6 && h < 12;
                        }),
                        tarde: points.filter(p => {
                            const h = new Date(p.time).getHours();
                            return h >= 12 && h < 18;
                        }),
                        noite: points.filter(p => {
                            const h = new Date(p.time).getHours();
                            return h >= 18 && h < 24;
                        })
                    };

                    const periodNames = {
                        madrugada: 'Madrugada',
                        manha: 'Manhã',
                        tarde: 'Tarde',
                        noite: 'Noite'
                    };

                    const avg = arr => arr.length ? arr.reduce((a, b) => a + b) / arr.length : 0;
                    const round10 = v => Math.round(v / 10) * 10;

                    for (const key in periods) {
                        const period = periods[key];
                        const cloudAvg = round10(avg(period.map(p => p.cloud_cover || 0)));
                        const precipSum = period.reduce((sum, p) => sum + (p.precipitation || 0), 0);
                        const storm = period.some(p => [95, 96, 99].includes(p.weathercode)); // ⚡ TEMPESTADE POR PERÍODO

                        const div = document.createElement('div');
                        div.className = 'row';
                        div.style.flexDirection = 'column';
                        div.innerHTML = `
                    <p style="font-weight:700; margin-bottom:8px;">${periodNames[key]}</p>
                    <p style="margin:4px 0">${cloudDescription(cloudAvg)} (${cloudAvg}%)</p>
                    <p style="margin:4px 0">${rainDescription(precipSum)} (${precipSum.toFixed(1)} mm)</p>
                    ${storm ? `<p style="margin:4px 0">Risco de tempestades</p>` : ''}
                `;
                        card.appendChild(div);
                    }

                    const backDiv = document.createElement('div');
                    backDiv.style.textAlign = 'center';
                    backDiv.style.marginTop = '10px';
                    backDiv.innerHTML = `
                <button class="back-btn" style="background:#000;color:#fff;border:1px solid #333;padding:10px 14px;border-radius:8px;cursor:pointer;">Voltar</button>
            `;
                    card.appendChild(backDiv);

                    backDiv.querySelector('.back-btn').addEventListener('click', () => {
                        renderDays(dayMap);
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    });
                });

                cardsEl.appendChild(card);
            }

            function cloudDescription(percent) {
                if (percent <= 10) return 'Céu limpo';
                if (percent <= 40) return 'Poucas nuvens';
                if (percent <= 60) return 'Muitas nuvens';
                if (percent <= 80) return 'Maioria nublado';
                return 'Nublado';
            }

            function rainDescription(mm) {
                if (mm < 1) return 'Sem chuva';
                if (mm < 5) return 'Chuva leve';
                if (mm < 15) return 'Chuva moderada';
                return 'Chuva forte';
            }
        }

        async function fetchForecast(lat, lon, timezone = 'auto') {
            const url = new URL(forecastBase);
            url.searchParams.set('latitude', lat);
            url.searchParams.set('longitude', lon);
            url.searchParams.set('hourly', 'temperature_2m,relative_humidity_2m,precipitation,cloud_cover,wind_gusts_10m,weathercode'); // ✅ adicionado weathercode
            url.searchParams.set('models', model);
            url.searchParams.set('timezone', timezone);
            url.searchParams.set('forecast_days', '15');
            const res = await fetch(url.toString());
            if (!res.ok) throw new Error('Erro ao buscar previsão');
            return await res.json();
        }

        async function searchLocation(query) {
            const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&q=${encodeURIComponent(query)}&limit=1`;
            const res = await fetch(url);
            const data = await res.json();
            if (!data[0]) throw new Error('Local não encontrado');
            const place = data[0];
            const addr = place.address || {};
            const city = addr.city || addr.town || addr.village || addr.municipality || '';
            const state = addr.state || '';
            const country = addr.country || '';
            locationName.textContent = `📌 ${city}${state ? ', ' + state : ''}${country ? ' - ' + country : ''}`;
            return { lat: parseFloat(place.lat), lon: parseFloat(place.lon) };
        }

        searchForm.addEventListener('submit', async e => {
            e.preventDefault();
            const q = cityInput.value.trim();
            if (!q) return;
            try {
                locationName.textContent = 'Buscando...';
                cardsEl.innerHTML = '';
                const { lat, lon } = await searchLocation(q);
                const forecast = await fetchForecast(lat, lon);
                const times = forecast.hourly.time;
                const arrays = {
                    temperature_2m: forecast.hourly.temperature_2m || [],
                    relative_humidity_2m: forecast.hourly.relative_humidity_2m || [],
                    precipitation: forecast.hourly.precipitation || [],
                    cloud_cover: forecast.hourly.cloud_cover || [],
                    wind_gusts_10m: forecast.hourly.wind_gusts_10m || [],
                    weathercode: forecast.hourly.weathercode || [] // ✅ adicionado
                };
                const dayMap = groupHourlyByDate(times, arrays);
                renderDays(dayMap);
            } catch {
                locationName.textContent = 'Erro ao carregar';
            }
        });

        document.getElementById('geoButton').addEventListener('click', () => {
            if (!navigator.geolocation) return alert('Geolocalização não suportada.');
            locationName.textContent = 'Obtendo localização...';
            navigator.geolocation.getCurrentPosition(async pos => {
                const { latitude, longitude } = pos.coords;
                const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&addressdetails=1`;
                const res = await fetch(url);
                const data = await res.json();
                const addr = data.address || {};
                const city = addr.city || addr.town || addr.village || '';
                const state = addr.state || '';
                const country = addr.country || '';
                locationName.textContent = `📌 ${city}${state ? ', ' + state : ''}${country ? ' - ' + country : ''}`;
                const forecast = await fetchForecast(latitude, longitude);
                const times = forecast.hourly.time;
                const arrays = {
                    temperature_2m: forecast.hourly.temperature_2m || [],
                    relative_humidity_2m: forecast.hourly.relative_humidity_2m || [],
                    precipitation: forecast.hourly.precipitation || [],
                    cloud_cover: forecast.hourly.cloud_cover || [],
                    wind_gusts_10m: forecast.hourly.wind_gusts_10m || [],
                    weathercode: forecast.hourly.weathercode || [] // ✅ adicionado
                };
                const dayMap = groupHourlyByDate(times, arrays);
                renderDays(dayMap);
            });
        });
    </script>



</body>

</html>