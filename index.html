<!doctype html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Previsão 15 dias — Preto & Branco</title>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #ffffff;
            --fg: #000000;
            --muted: #333333;
            --card: #f6f6f6
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: 'Ubuntu', sans-serif;
            background: var(--bg);
            color: var(--fg);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        header {
            display: flex;
            gap: 16px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .brand {
            display: flex;
            gap: 14px;
            align-items: baseline;
            flex-wrap: wrap;
        }

        .brand h1 {
            font-size: 18px;
            margin: 0;
            font-weight: 700;
            letter-spacing: 0.2px
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        input[type=text] {
            padding: 12px 14px;
            border: 1px solid var(--muted);
            background: #fefefe;
            color: var(--fg);
            font-size: 14px;
            min-width: 220px;
            flex: 1;
            border-radius: 8px;
            transition: all 0.25s ease;
            font-family: 'Ubuntu', sans-serif;
        }

        input[type=text]:focus {
            outline: none;
            border-color: var(--fg);
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1);
        }

        button {
            padding: 12px 18px;
            border: 1px solid var(--fg);
            background: var(--fg);
            color: var(--bg);
            cursor: pointer;
            font-weight: 600;
            border-radius: 8px;
            transition: all 0.25s ease;
            font-family: 'Ubuntu', sans-serif;
        }

        /* Botão Localizar */
        #geoButton {
            background: var(--fg);
            color: var(--bg);
        }

        .meta {
            font-size: 13px;
            color: var(--muted);
        }

        main {
            display: block
        }

        .location-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-top: 6px;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }

        .cards {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 14px;
        }

        .card {
            background: var(--card);
            border: 1px solid #e8e8e8;
            padding: 14px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .card .date {
            font-size: 22px;
            font-weight: 700
        }

        .row {
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            padding: 5px;
            border-bottom: 2px solid rgb(232, 232, 232);
        }

        .row-text {
            color: var(--muted)
        }

        .row-data {
            font-size: 20px;
            font-weight: bolder;
        }

        footer {
            margin-top: 18px;
            font-size: 13px;
            color: var(--muted)
        }

        @media (max-width:520px) {

            body {
                padding: 15px 8px;
            }

            header {
                display: grid;
                justify-content: center;
                justify-items: center;
                text-align: center;
            }

            input[type=text] {
                min-width: 100%;
                margin-bottom: 5px;
            }

            button {
                width: 100%;
                margin-bottom: 5px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .location-row {
                align-items: center;
            }

            #locationName {
                text-align: center;
            }

            /* CENTRALIZAR TEXTOS ABAIXO DO INPUT NO CELULAR */
            .location-row>div:last-child {
                margin-left: 0 !important;
                text-align: center !important;
                width: 100%;
            }

            .cards {
                display: grid;
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="brand">
            <h1>Previsão - 15 dias</h1>
        </div>
        <div class="controls">
            <form id="searchForm">
                <input type="text" id="cityInput" placeholder="Buscar cidade (ex: Recife, BR)"
                    aria-label="Buscar cidade" />
                <button type="submit">Buscar</button>
                <button type="button" id="geoButton" title="Usar minha localização">Localizar</button>
            </form>
        </div>
    </header>

    <main>
        <div class="location-row">
            <div id="locationName" style="font-weight:700"></div>
            <div
                style="margin-left:auto;text-align:right;background-color: rgb(255, 237, 224);border-radius: 10px;padding: 7px;">
                <div class="meta">Hoje: <span id="todayDate"></span></div>
                <div class="small">Dados: Open-Meteo (modelo ecmwf_ifs)</div>
            </div>
        </div>
        <section id="forecastSection">
            <div class="cards" id="cards"></div>
        </section>
    </main>

    <footer>
        Mostrando até 15 dias de previsão. A Busca utiliza a API de geocoding do Nominatim (OpenStreetMap).
    </footer>

    <script>
        const forecastBase = 'https://api.open-meteo.com/v1/forecast';
        const model = 'ecmwf_ifs';

        const cityInput = document.getElementById('cityInput');
        const searchForm = document.getElementById('searchForm');
        const locationName = document.getElementById('locationName');
        const cardsEl = document.getElementById('cards');
        const todayDate = document.getElementById('todayDate');

        const today = new Date();
        const weekday = new Intl.DateTimeFormat('pt-BR', { weekday: 'long' }).format(today);
        const date = new Intl.DateTimeFormat('pt-BR', { day: '2-digit', month: '2-digit' }).format(today); // só dia/mês
        todayDate.textContent = `${date} - ${weekday}`;

        function formatDateLabel(iso) {
            const d = new Date(iso);
            const weekday = new Intl.DateTimeFormat('pt-BR', { weekday: 'short' }).format(d);
            const date = new Intl.DateTimeFormat('pt-BR', { day: '2-digit', month: '2-digit' }).format(d); // só dia/mês
            return { weekday, date };
        }

        function groupHourlyByDate(times, arrays) {
            const map = new Map();
            for (let i = 0; i < times.length; i++) {
                const day = times[i].slice(0, 10);
                if (!map.has(day)) map.set(day, []);
                const point = {};
                for (const key in arrays) { point[key] = arrays[key][i]; }
                map.get(day).push(point);
            }
            return map;
        }

        function summarizeDay(points) {
            const n = points.length || 1;
            let tMin = Infinity, tMax = -Infinity, rhMin = Infinity, rhMax = -Infinity;
            let precipSum = 0, cloudSum = 0, gustMax = 0;
            for (const p of points) {
                if (p.temperature_2m != null) { if (p.temperature_2m < tMin) tMin = p.temperature_2m; if (p.temperature_2m > tMax) tMax = p.temperature_2m; }
                if (p.relative_humidity_2m != null) { if (p.relative_humidity_2m < rhMin) rhMin = p.relative_humidity_2m; if (p.relative_humidity_2m > rhMax) rhMax = p.relative_humidity_2m; }
                if (p.precipitation != null) precipSum += p.precipitation;
                if (p.cloud_cover != null) cloudSum += p.cloud_cover;
                if (p.wind_gusts_10m != null && p.wind_gusts_10m > gustMax) gustMax = p.wind_gusts_10m;
            }
            const cloudMean = cloudSum / n;
            return { tMin, tMax, rhMin, rhMax, precipSum, cloudMean, gustMax };
        }

        function renderDays(dayMap) {
            cardsEl.innerHTML = '';
            const entries = Array.from(dayMap.entries()).slice(0, 15);
            for (const [day, points] of entries) {
                const iso = day + 'T00:00:00';
                const labels = formatDateLabel(iso);
                const s = summarizeDay(points);
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
          <div class="date">${labels.date} (${labels.weekday})</div>
          <div class="row"><div class="row-text">Temperatura (°C)</div><div class="row-data">${isFinite(s.tMin) ? s.tMin.toFixed(0) : '-'} a ${isFinite(s.tMax) ? s.tMax.toFixed(0) : '-'}</div></div>
          <div class="row"><div class="row-text">Precipitação (mm)</div><div class="row-data">${s.precipSum.toFixed(1)}</div></div>
          <div class="row"><div class="row-text">Umidade (%)</div><div class="row-data">${isFinite(s.rhMin) ? s.rhMin.toFixed(0) : '-'} a ${isFinite(s.rhMax) ? s.rhMax.toFixed(0) : '-'}</div></div>
          <div class="row"><div class="row-text">Cobertura de nuvens (%)</div><div class="row-data">${s.cloudMean.toFixed(0)}</div></div>
          <div class="row"><div class="row-text">Rajadas de vento (km/h)</div><div class="row-data">${s.gustMax.toFixed(0)}</div></div>`;
                cardsEl.appendChild(card);
            }
        }

        async function fetchForecast(lat, lon, timezone = 'auto') {
            const url = new URL(forecastBase);
            url.searchParams.set('latitude', lat);
            url.searchParams.set('longitude', lon);
            url.searchParams.set('hourly', 'temperature_2m,relative_humidity_2m,precipitation,cloud_cover,wind_gusts_10m');
            url.searchParams.set('models', model);
            url.searchParams.set('timezone', timezone);
            url.searchParams.set('forecast_days', '15');
            const res = await fetch(url.toString());
            if (!res.ok) throw new Error('Erro ao buscar previsão');
            return await res.json();
        }

        // --- Função para buscar pelo input (cidade, estado, país) usando Nominatim ---
        async function searchLocation(query) {
            const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&q=${encodeURIComponent(query)}&limit=1`;
            const res = await fetch(url);
            if (!res.ok) throw new Error('Erro ao buscar localização');
            const data = await res.json();
            if (!data[0] || !data[0].lat) throw new Error('Local não encontrado');
            const place = data[0];
            const addr = place.address || {};
            const city = addr.city || addr.town || addr.village || addr.municipality || '';
            const state = addr.state || '';
            const country = addr.country || '';
            locationName.textContent = `${city}${state ? ', ' + state : ''}${country ? ' - ' + country : ''}`;
            return { lat: parseFloat(place.lat), lon: parseFloat(place.lon) };
        }

        searchForm.addEventListener('submit', async e => {
            e.preventDefault();
            const q = cityInput.value.trim();
            if (!q) return;
            try {
                locationName.textContent = 'Buscando...';
                cardsEl.innerHTML = '';
                const { lat, lon } = await searchLocation(q);
                const forecast = await fetchForecast(lat, lon);
                const times = forecast.hourly.time;
                const arrays = {
                    temperature_2m: forecast.hourly.temperature_2m || [],
                    relative_humidity_2m: forecast.hourly.relative_humidity_2m || [],
                    precipitation: forecast.hourly.precipitation || [],
                    cloud_cover: forecast.hourly.cloud_cover || [],
                    wind_gusts_10m: forecast.hourly.wind_gusts_10m || []
                };
                const dayMap = groupHourlyByDate(times, arrays);
                renderDays(dayMap);
            } catch (err) {
                console.error(err);
                locationName.textContent = 'Erro ao carregar';
            }
        });

        // --- Botão Localizar ---
        const geoButton = document.getElementById('geoButton');
        geoButton.addEventListener('click', () => {
            if (!navigator.geolocation) { alert('Geolocalização não é suportada neste navegador.'); return; }
            locationName.textContent = 'Obtendo sua localização...';
            cardsEl.innerHTML = '';

            navigator.geolocation.getCurrentPosition(async (pos) => {
                const { latitude, longitude } = pos.coords;
                try {
                    // Reverse geocoding via Nominatim
                    const url = `https://nominatim.openstreetmap.org/reverse?format=json&addressdetails=1&lat=${latitude}&lon=${longitude}`;
                    const res = await fetch(url);
                    const data = await res.json();
                    const addr = data.address || {};
                    const city = addr.city || addr.town || addr.village || addr.municipality || '';
                    const state = addr.state || '';
                    const country = addr.country || '';
                    locationName.textContent = `${city}${state ? ', ' + state : ''}${country ? ' - ' + country : ''}`;

                    const forecast = await fetchForecast(latitude, longitude);
                    const times = forecast.hourly.time;
                    const arrays = {
                        temperature_2m: forecast.hourly.temperature_2m || [],
                        relative_humidity_2m: forecast.hourly.relative_humidity_2m || [],
                        precipitation: forecast.hourly.precipitation || [],
                        cloud_cover: forecast.hourly.cloud_cover || [],
                        wind_gusts_10m: forecast.hourly.wind_gusts_10m || []
                    };
                    const dayMap = groupHourlyByDate(times, arrays);
                    renderDays(dayMap);
                } catch (err) {
                    console.error(err);
                    locationName.textContent = 'Erro ao obter previsão pela localização.';
                }
            }, (err) => {
                console.error(err);
                locationName.textContent = 'Permissão negada ou erro ao obter localização.';
            });
        });
    </script>
</body>

</html>